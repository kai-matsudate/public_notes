# Linux を構成する主要概念について Overview

## システムコール

- アプリケーションがカーネルの管理するリソースへのアクセスや動作を要求する関数
  - 例：read, write, fork, open, close

### システムコール呼び出しの仕組み（x86_64の場合）
1. システムコール番号を %rax レジスタにセット
2. 引数を %rdi, %rsi, %rdx, %r10, %r8, %r9 レジスタにセット（最大6引数）
3. `syscall` 命令を実行（CPUが特権レベルを3→0に変更）
4. カーネルがシステムコールテーブルを参照して処理実行
5. 戻り値を %rax レジスタにセット
6. エラー時は負の値（-errno）を返す
7. `sysret` 命令でユーザー空間に復帰

※ 32bit（i386）では int 0x80 割り込みを使用していたが現在は非推奨
- [参考：システムコール実装詳細](https://www.ffri.jp/assets/files/research/research_papers/SystemCall.pdf)
- [x86_64のシステムコール](https://yuma.ohgami.jp/x86_64-Jisaku-OS-3/01_syscall.html)

**1. システムコール番号の確認**
```bash
# システムコール番号一覧（x86_64）
ausyscall --dump | head -20
# または
grep __NR_ /usr/include/asm/unistd_64.h | head -10
```

**2. straceでリアルタイム追跡**
```bash
# catコマンドのシステムコール追跡
strace -e trace=open,openat,read,write,close cat /etc/hostname 2>&1

# 出力例：
# openat(AT_FDCWD, "/etc/hostname", O_RDONLY) = 3
# read(3, "myhost\n", 131072) = 7
# write(1, "myhost\n", 7) = 7
# close(3) = 0
```

**3. 実行中プロセスのシステムコール確認**
```bash
# 別ターミナルでsleepを実行してPIDを確認
sleep 100 &
cat /proc/$!/syscall  # 現在実行中のシステムコール
```

**カーネルソース参照**
- [x86_64 システムコールテーブル](https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl)
- [システムコールエントリポイント](https://github.com/torvalds/linux/blob/master/arch/x86/entry/entry_64.S)

## glibc
- GNU C ライブラリ
- システムコールのラッパーと便利関数を提供

### 1. システムコールのラッパー関数
純粋にシステムコールを呼びやすくした薄いラッパー

**ファイル操作**
- open() / close() / read() / write() - 基本的なファイルI/O
- lseek() - ファイルポジション移動
- stat() / fstat() / lstat() - ファイル情報取得
- chmod() / chown() - 権限/所有者変更

**プロセス管理**
- fork() - 子プロセス作成
- exec*() ファミリー - プログラム実行
- wait() / waitpid() - 子プロセス終了待機
- exit() / _exit() - プロセス終了

**シグナル処理**
- signal() / sigaction() - シグナルハンドラ設定
- kill() - シグナル送信
- pause() - シグナル待機

**メモリマッピング**
- mmap() / munmap() - メモリマッピング
- brk() / sbrk() - ヒープサイズ変更

### 2. 高レベル便利関数（標準C/POSIX）

**動的メモリ管理**
- malloc() / free() / calloc() / realloc() - ヒープメモリ管理
- memcpy() / memmove() / memset() - メモリ操作

**文字列処理**
- str*() 系関数群 - 文字列操作全般
- strtok_r() - スレッドセーフなトークン分割

**ストリームI/O (stdio)**
- fopen() / fclose() - ストリーム管理
- fread() / fwrite() / fgets() / fputs() - バッファリングI/O
- fprintf() / fscanf() - 書式指定I/O

**ディレクトリ操作**
- opendir() / readdir() / closedir() - ディレクトリ走査
- mkdir() / rmdir() - ディレクトリ作成/削除

**時刻処理**
- time() / gettimeofday() / clock_gettime() - 時刻取得（精度別）
- localtime_r() / gmtime_r() - スレッドセーフな時刻変換

### 3. POSIX Threads (pthread)

**スレッド基本操作**
- pthread_create() / pthread_join() / pthread_detach() - スレッド管理

**同期プリミティブ**
- pthread_mutex_*() - 相互排他
- pthread_cond_*() - 条件変数
- pthread_rwlock_*() - 読み書きロック
- pthread_once() - 一度だけ実行保証

**スレッド固有データ**
- pthread_key_*() / pthread_*specific() - TLS (Thread Local Storage)

## コンパイラ

- gcc - GNU Compiler Collection
- システムコールのインターフェースをglibcを通じて利用

## API vs ABI

**API (Application Programming Interface)**
- ソースコードレベルでの関数・データ構造の定義
- プログラマが使用するインターフェース

**ABI (Application Binary Interface)**
- バイナリレベルでの互換性仕様
- 呼び出し規約、レジスタ使用法、構造体のメモリレイアウトなど
- アーキテクチャ毎に異なる（x86_64, ARM, RISC-V等）
- [Linuxカーネルのアーキテクチャ別実装](https://github.com/torvalds/linux/tree/master/arch)

## 標準仕様

- POSIX - 移植性のあるOSインターフェース標準
- SUSv3/SUSv4 - Single UNIX Specification
- C99/C11 - C言語標準

## 標準的な概念

### ファイルとファイルシステム

- Everything is a file!
- 開いたファイルは fd でカーネルが管理

#### 通常ファイル

- Linux 上では只のバイト列
- offset というメタデータを持ち、読み書き時に更新する
- trancate: ファイルサイズの更新
  - 大きくすると 0 埋めするらしい
- fd を異なるプロセス間で共有することも出来る
- inode: ファイルのエントリポイントを含むメタデータを持つ
  - inode番号: inode を一意に識別する番号

### ディレクトリ

- ディレクトリ：ファイルの一種
  - リンク（ファイル名とinode番号の対応）を保持する特殊ファイル

- パス名解決
  - カーネルはファイル名から再帰的に木構造を探索してinode番号を特定
  - dcache（ディレクトリエントリキャッシュ）による高速化
  - 参考：[dcacheの仕組み](https://github.com/hiboma/hiboma/blob/master/kernel/dentry_cache.md)

- ハードリンク
  - 同一inode番号に対して複数のファイル名を関連付け
  - 参照カウンタでファイル削除を管理（カウンタが0になったら削除）
  - 同一ファイルシステム内でのみ作成可能

- シンボリックリンク
  - 別ファイルへのパスを保持する特殊ファイル
  - ファイルシステムを跨いで作成可能
  - パス解決のオーバーヘッドあり

### スペシャルファイル

- キャラクタデバイス
  - ファイルをFIFOキューとして扱い、デバイスドライバからの書き込みを受け取る
  - キーボードやシリアルポートなど
- ブロックデバイス
  - HD, CD などの順序無しバイト列
  - バイブストレージ
- 名前つきパイプ
  - プロセス間でのデータ通信手段
  - プログラマブルにアクセス可能なパイプ
  - ファイルとの違い：
    - メモリ上でのみデータを保持
    - FIFO構造(seekableでない)
- ソケット
  - ネットワークIOに利用

### FS

- ファイルシステムを分割する気持ち
  - マウントポイント毎の独立性保証
    - マウントポイントAで容量不足が起きても他のマウントポイントに影響しない
  - ext4, xfs, btrfs, nfs, tmpfs など様々な FS が存在
  - https://www.geeksforgeeks.org/operating-systems/virtual-file-system/

- セクタ
  - ブロックデバイス(ストレージへのIOの単位)
  - 512 がち
- ブロック
  - fs へのIOの単位
  - セクタの累乗
  - 512, 1K, 4K

- プロセス毎の namespace 方式をLinuxで採用
- プロセスごとにファイル/ディレクトリの階層を保持可能
  - コンテナだね！

### プロセス

- プロセス：プログラムの実行インスタンス
- プログラム：実行可能ファイル（ELF形式など）

#### ELFファイルの解析
```sh
readelf -h sample        # ELFヘッダ情報
readelf -l sample        # プログラムヘッダ
readelf -S sample        # セクションヘッダ
readelf -s sample        # シンボルテーブル
objdump -d sample        # 逆アセンブル
file sample              # ファイル形式の確認
```

**1. /bin/ls を解析**
```bash
# ELFヘッダを確認（マジックナンバー、エントリポイント等）
readelf -h /bin/ls | head -20

# プログラムヘッダ（メモリへのロード情報）
readelf -l /bin/ls

# セクション情報（.text, .data, .bss等）
readelf -S /bin/ls | grep -E "\.text|\.data|\.bss"

# 逆アセンブル（main関数を探す）
objdump -d /bin/ls | grep -A20 "<main>:"
```

**2. 簡単なプログラムで確認**
```c
// hello.c
#include <stdio.h>
int main() { printf("Hello\n"); return 0; }
```
```bash
gcc -o hello hello.c
size hello  # text, data, bssセクションのサイズ確認
ldd hello   # 動的リンクライブラリの確認
```

#### マルチタスクの種類
- **プリエンプティブマルチタスク**（現在のLinux）
  - カーネルがCPU時間を強制的に切り替え
  - プロセスは透過的に実行される
- **ノンプリエンプティブマルチタスク**（協調的）
  - プロセスが自発的にCPUを譲る
- **仮想メモリ空間**
  - 各プロセスは独立したメモリ空間を持つ
  - [仮想メモリ詳細](https://chips-gadgets.jp/technology/memory/virtual-memory)

#### スレッド
- プロセス内の実行単位
- 同一プロセス内でメモリ空間を共有

#### プロセスツリー
- initプロセス（PID 1）がルート
- fork()で子プロセスを生成
- 親プロセスは子プロセスの終了をwait()で待機
  - ゾンビプロセス：終了済みだが親がwait()していない状態

**1. プロセスツリーの確認**
```bash
# プロセスツリーを視覚的に表示
pstree -p | head -20

# systemd (PID 1) の確認
ls -la /proc/1/exe
cat /proc/1/comm
```

**2. 現在のシェルプロセス情報**
```bash
# プロセスID確認
echo $$

# プロセスの詳細情報
cat /proc/$$/status | head -20    # プロセス状態
cat /proc/$$/limits               # リソース制限
cat /proc/$$/environ | tr '\0' '\n' | head  # 環境変数
```

**3. メモリマップの確認**
```bash
# プロセスのメモリレイアウト表示
cat /proc/$$/maps | head -20

# より詳細な情報（RSS、PSS等）
cat /proc/$$/smaps | head -50
```

**4. ゾンビプロセスの作成と確認**
```bash
# ゾンビプロセスを意図的に作成
(sleep 1 & exec sleep 100) &
ps aux | grep defunct
```

**カーネルソース参照**
- [proc filesystem実装](https://github.com/torvalds/linux/tree/master/fs/proc)
- [task_struct構造体（プロセス情報）](https://github.com/torvalds/linux/blob/master/include/linux/sched.h)

### ユーザとグループ

#### ユーザID (UID)
- 各ユーザは一意なuid を持つ
- プロセスは3種類のUIDを持つ：
  - **実UID (uid)**: プロセスを起動したユーザ
  - **実効UID (euid)**: 権限チェックに使用される
  - **保存UID (suid)**: setuidビット付きプログラムで使用

#### グループID (GID)
- ユーザは少なくとも1つのグループに所属
- プロセスも同様にgid, egid, sgidを持つ

### 権限

ファイルパーミッション：owner/group/otherに対してr(4)/w(2)/x(1)
- 例：755 = rwxr-xr-x（owner:全権限、group/other:読み実行のみ）
- ディレクトリのx権限 = 通過（アクセス）権限

### シグナル

プロセス間の非同期通信メカニズム

**主要なシグナル**
- SIGINT (2): Ctrl+C による割り込み
- SIGTERM (15): 終了要求（キャッチ可能）
- SIGKILL (9): 強制終了（キャッチ不可）
- SIGSEGV (11): セグメンテーション違反
- SIGCHLD (17): 子プロセス状態変化

**シグナルハンドラ**
- signal()：簡易版（非推奨）
- sigaction()：詳細設定可能（推奨）

### プロセス間通信 (IPC)

- **パイプ**：親子プロセス間の単方向通信
- **名前付きパイプ (FIFO)**：無関係なプロセス間通信
- **セマフォ**：プロセス間の同期制御
- **共有メモリ**：高速なデータ共有
- **メッセージキュー**：メッセージベースの通信

### ヘッダファイル

- 標準Cライブラリの関数宣言と定数定義
- 主要なヘッダ：stdio.h, stdlib.h, unistd.h, sys/types.h等

### エラー処理

システムコールのエラーはerrnoグローバル変数で通知

**エラー処理の基本**
```c
if (syscall() == -1) {
    perror("syscall failed");  // エラーメッセージ出力
    // または
    fprintf(stderr, "Error: %s\n", strerror(errno));
}
```

**主要なエラーコード**
- EPERM (1): 権限なし
- ENOENT (2): ファイル/ディレクトリなし
- EINTR (4): シグナルで中断
- EIO (5): I/Oエラー
- EACCES (13): アクセス拒否
- EINVAL (22): 無効な引数
- EAGAIN (11): リソース一時的に利用不可

参考：
- [エラーコード一覧](https://www.chromium.org/chromium-os/developer-library/reference/linux-constants/errnos/)
- [perror(3)](https://linuxjm.sourceforge.io/html/LDP_man-pages/man3/perror.3.html)
- [strerror(3)](https://linuxjm.sourceforge.io/html/LDP_man-pages/man3/strerror.3.html)

**1. errnoの値を確認**
```bash
# 存在しないファイルをオープンしてエラー確認
strace -e openat cat /nonexistent 2>&1 | grep -E "ENOENT|No such"

# errnoのマクロと値の対応
errno -l | head -20  # errnoコマンドがある場合
# または
grep -E "^#define\s+E" /usr/include/asm-generic/errno-base.h
```

**2. 実際のエラー処理を観察**
```c
// error_demo.c
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>

int main() {
    int fd = open("/nonexistent", O_RDONLY);
    if (fd == -1) {
        printf("errno = %d\n", errno);
        printf("error: %s\n", strerror(errno));
        perror("open failed");
    }
    return 0;
}
```
```bash
gcc -o error_demo error_demo.c
./error_demo
strace -e openat ./error_demo 2>&1
```

**カーネルソース参照**
- [エラーコード定義](https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/errno-base.h)
- [エラーコード定義（拡張）](https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/errno.h)
