# ユーザランドでのバッファリング

## 気持ち

- 基本的にシステム側のバッファリング機構で効率化のためのバッファリングは十分である
- ただシステムのみに合わせると、ブロックサイズの2冪に合わせる必要がある
- 一方でアプリケーションで必要な単位は文字単位、行単位など多様
- →ユーザランドでのバッファリングを行うことで柔軟に対応可能

## stdio
- ファイルディスクリプタをFILE構造体（ファイルポインタ）でラップ
- ユーザー空間でのバッファリングを提供

### 主要な関数

**ファイル操作**
- `fopen()` / `fclose()` - ストリームのオープン/クローズ
- `fcloseall()` - 全ストリームのクローズ（GNU拡張）

**文字単位I/O**
- `fgetc()` / `getc()` - 1文字読み込み（int型で返す、EOFチェック用）
- `fputc()` / `putc()` - 1文字書き込み
- `ungetc()` - 1文字をストリームに戻す

**行単位I/O**
- `fgets()` - 1行読み込み（改行文字を含む）
- `fputs()` - 文字列書き込み（改行文字は追加しない）

**バイナリI/O**
- `fread()` - バイナリ読み込み（要素数×サイズ）
- `fwrite()` - バイナリ書き込み（要素数×サイズ）
- 戻り値：実際に読み書きした要素数

**ストリーム位置操作**
- `fseek()` - ファイル位置の移動
- `ftell()` - 現在位置の取得
- `rewind()` - 先頭に戻る

**バッファ制御**
- `fflush()` - ユーザー空間バッファを強制的にカーネルへ書き出し
- `setvbuf()` - バッファリングモードの設定

**エラー処理**
- `ferror()` - エラーフラグのチェック
- `feof()` - EOFフラグのチェック
- `clearerr()` - エラー/EOFフラグのクリア

## バッファリングの種類

### バッファリングなし（_IONBF）
- 各文字を即座にカーネルへ書き込み
- 用途：エラーメッセージ、重要なログ
- 標準エラー出力（stderr）のデフォルト

### 行バッファリング（_IOLBF）
- 改行文字まで、またはバッファ満杯でフラッシュ
- 用途：対話的な端末I/O
- 標準出力（stdout）のデフォルト（端末接続時）

### フルバッファリング（_IOFBF）
- バッファ満杯、fflush()、またはfclose()でフラッシュ
- 用途：ファイルI/O
- 標準出力のデフォルト（ファイルへリダイレクト時）

### バッファリングモードの設定
```c
// setvbuf(FILE *stream, char *buf, int mode, size_t size)
setvbuf(fp, NULL, _IONBF, 0);        // バッファなし
setvbuf(fp, NULL, _IOLBF, 0);        // 行バッファ
setvbuf(fp, buffer, _IOFBF, 4096);   // フルバッファ（4KB）
```

**1. バッファリングモードによる動作の違い**
```c
// buffer_demo.c
#include <stdio.h>
#include <unistd.h>

int main() {
    printf("Mode 1: No buffering\n");
    setvbuf(stdout, NULL, _IONBF, 0);
    for(int i = 0; i < 5; i++) {
        putchar('.');
        sleep(1);
    }

    printf("\nMode 2: Line buffering\n");
    setvbuf(stdout, NULL, _IOLBF, 0);
    for(int i = 0; i < 5; i++) {
        printf("Line %d", i);  // 改行なし
        sleep(1);
        printf("\n");  // ここでフラッシュ
    }

    printf("Mode 3: Full buffering\n");
    setvbuf(stdout, NULL, _IOFBF, 1024);
    for(int i = 0; i < 5; i++) {
        printf("Data %d ", i);
        sleep(1);
    }
    printf("\n");  // バッファに溜まったまま
    fflush(stdout);  // 明示的にフラッシュ

    return 0;
}
```

**2. straceでシステムコール呼び出しを比較**
```bash
# コンパイル
gcc -o buffer_demo buffer_demo.c

# システムコール追跡
strace -e write ./buffer_demo 2>&1 | grep -c "write"

# バッファなしの場合、writeが文字数分呼ばれる
# 行バッファは改行ごと、フルバッファは最後に一括
```

**3. Python/Shellでの確認**
```bash
# Python - デフォルトは行バッファ
python3 -c "
import sys, time
for i in range(5):
    print('.', end='')  # 改行なし→バッファに溜まる
    time.sleep(1)
print()  # ここでフラッシュ
"

# unbufferedモード
python3 -u -c "
import sys, time
for i in range(5):
    print('.', end='')  # 即座に出力
    sys.stdout.flush()  # または明示的フラッシュ
    time.sleep(1)
"
```

## スレッドセーフ

### stdioの内部ロック機構
- 各FILE構造体は内部ロックを持つ
- 各stdio関数呼び出しで自動的にロック取得/解放
- 関数単位での原子性を保証

### 複数操作の原子性が必要な場合

**手動ロック制御**
```c
flockfile(fp);           // ストリームをロック
// 複数のstdio操作をアトミックに実行
fputc('A', fp);
fputc('B', fp);
funlockfile(fp);         // ロック解放
```

**ロックなしバージョン（高速化）**
```c
flockfile(fp);
// _unlockedサフィックスの関数は内部ロックを取らない
while ((c = fgetc_unlocked(fp)) != EOF) {
    fputc_unlocked(toupper(c), out);
}
funlockfile(fp);
```

利用可能な_unlocked関数：
- `fgetc_unlocked()` / `fputc_unlocked()`
- `fgets_unlocked()` / `fputs_unlocked()`
- `fread_unlocked()` / `fwrite_unlocked()`

## stdio への批判と二重バッファリング問題

**二重バッファリングの問題**
```
アプリケーション → stdioバッファ → カーネルバッファ → ディスク
                    （ユーザー空間）    （カーネル空間）
```

- メモリ使用量が2倍
- コピー処理のオーバーヘッド
- キャッシュ効率の低下

**批判への反論**
- stdioバッファによる最適化（文字/行単位→ブロック単位変換）
- システムコール呼び出し回数の削減
- 移植性と標準化のメリット

代替実装：sfio、io_uring等があるが、stdioは標準として広く使用され続けている

**1. 二重バッファリングの可視化**
```c
// double_buffer.c
#include <stdio.h>
#include <unistd.h>
#include <string.h>

int main() {
    FILE *fp = fopen("/tmp/test.txt", "w");

    // stdioバッファに書き込み
    fprintf(fp, "Hello, World!\n");
    printf("Written to stdio buffer\n");

    // この時点ではまだカーネルバッファにも届いていない
    system("cat /tmp/test.txt");  // 空のはず

    // fflush()でカーネルバッファへ
    fflush(fp);
    printf("Flushed to kernel buffer\n");

    // カーネルバッファにはあるがディスクには未反映
    system("cat /tmp/test.txt");  // 表示される

    // fsyncでディスクへ強制書き込み
    fsync(fileno(fp));
    printf("Synced to disk\n");

    fclose(fp);
    return 0;
}
```

**2. straceで二段階のバッファリングを確認**
```bash
# プログラム実行時のシステムコール追跡
strace -e write,fsync ./double_buffer 2>&1

# write()はfflush()時に呼ばれる
# fsync()で実際のディスク書き込み
```

**3. メモリマップでバッファ領域を確認**
```bash
# プロセスのメモリマップ確認
cat /proc/$$/maps | grep -E "heap|libc.*\.so"

# FILE構造体のバッファはヒープに確保される
# libcのコード領域も確認可能
```

**4. /proc/[pid]/io でI/O統計確認**
```bash
# 簡単なテストプログラム
(
  exec 3> /tmp/iotest
  echo $$ > /tmp/pid
  sleep 30
) &

PID=$(cat /tmp/pid)

# I/O統計を確認
cat /proc/$PID/io

# write_bytes: プロセスがwrite()で書き込んだバイト数
# cancelled_write_bytes: キャンセルされた書き込み
```

**カーネルソース参照**
- [FILE構造体（glibc）](https://sourceware.org/git/?p=glibc.git;a=blob;f=libio/libio.h)
- [VFSレイヤーでのバッファ管理](https://github.com/torvalds/linux/blob/master/fs/read_write.c)

## 【デバッグテクニック】バッファリング問題の調査

**1. バッファリングが原因の典型的な問題**
```bash
# プログラムの出力が表示されない問題
./program | grep something  # パイプでフルバッファになる

# 解決策1: stdbufコマンド
stdbuf -oL ./program | grep something  # 行バッファに変更

# 解決策2: unbufferコマンド（expectパッケージ）
unbuffer ./program | grep something
```

**2. リアルタイムログ監視**
```bash
# tail -fが更新されない問題の対処
tail -f logfile | grep --line-buffered pattern

# またはPythonでunbuffered出力
python3 -u script.py | tee log.txt
```

**3. デッドロック回避**
```bash
# 双方向パイプでのデッドロック例
mkfifo pipe1 pipe2
./prog1 < pipe1 > pipe2 &
./prog2 < pipe2 > pipe1 &  # デッドロックの可能性

# 対策: バッファリングモード変更
stdbuf -i0 -o0 ./prog1 < pipe1 > pipe2 &
```
