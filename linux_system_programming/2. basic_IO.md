# ファイルIO

- プロセス毎にオープンしたファイルを管理： fd テーブル
  - fd: ファイルディスクリプタ。プロセスがファイルを識別するための整数値
  - fd テーブルの各エントリはオープンしたファイルを指すポインタを持つ
  - プロセスを fork した場合、親プロセスの fd テーブルが子プロセスにコピーされる
  - 任意のプロセスに存在する fd：
    - 標準入力 (0)
    - 標準出力 (1)
    - 標準エラー出力 (2)

**1. 現在のシェルのfd確認**
```bash
# 現在のシェルプロセスのfdテーブル
ls -la /proc/$$/fd/
# 出力例：
# 0 -> /dev/pts/1  (標準入力)
# 1 -> /dev/pts/1  (標準出力)
# 2 -> /dev/pts/1  (標準エラー)
# 255 -> /dev/pts/1 (bashが内部で使用)
```

**2. 新しいfdを作成して確認**
```bash
# ファイルをfd 3で開く
exec 3< /etc/hostname
ls -la /proc/$$/fd/3

# fd 3から読み込み
cat <&3

# fd 4で書き込み用に開く
exec 4> /tmp/test.txt
echo "Hello FD" >&4
cat /proc/$$/fd/4

# fdを閉じる
exec 3<&-
exec 4>&-
```

**3. プログラムでfdを確認**
```c
// fd_demo.c
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main() {
    printf("PID: %d\n", getpid());
    int fd1 = open("/etc/passwd", O_RDONLY);
    int fd2 = open("/tmp/test", O_WRONLY | O_CREAT, 0644);
    printf("fd1=%d, fd2=%d\n", fd1, fd2);

    // 別ターミナルで確認: ls -la /proc/[PID]/fd/
    sleep(30);

    close(fd1);
    close(fd2);
    return 0;
}
```

**カーネルソース参照**
- [ファイルディスクリプタ管理](https://github.com/torvalds/linux/blob/master/fs/file.c)
- [fdテーブル構造体](https://github.com/torvalds/linux/blob/master/include/linux/fdtable.h)

## open()
https://man7.org/linux/man-pages/man2/open.2.html

## creat()
https://man7.org/linux/man-pages/man3/creat.3p.html

## read()
https://man7.org/linux/man-pages/man2/read.2.html

- ブロッキングモード（デフォルト）：
  - データが利用可能になるまで呼び出し元をブロック
  - 要求したバイト数より少ない量を返すことがある（部分読み取り）
- ノンブロッキングモード（O_NONBLOCK フラグ）：
  - 読み取れるデータがない場合、即座に -1 を返し errno = EAGAIN
  - ネットワークI/Oやパイプで有用
## write()
https://man7.org/linux/man-pages/man2/write.2.html

- write は引数のバッファ -> カーネル空間のバッファへデータをコピーして return
- カーネル空間のバッファは bg でディスクに書き込み
  - ディスク反映の保証がない
  - 書き込み順序の保証がない
  - バッファ -> ディスクのエラーをトラッキング出来ない
  - カーネルの最長保持時間は 設定可能

## fsync()/fdatasync()
https://man7.org/linux/man-pages/man2/fsync.2.html
https://man7.org/linux/man-pages/man3/fdatasync.3p.html

- 引数で与えられた fd に関連するカーネルバッファを全てディスクに書き込む
- fsync はメタデータも書き込む
- fdatasync はデータのみ書き込む

## sync()
https://man7.org/linux/man-pages/man2/sync.2.html

- fd を指定せず、全てのカーネルバッファをディスクに書き込む

## O_SYNC フラグ

- open 時に O_SYNC フラグを指定すると、write 呼び出しが完了するまで戻らない
- fsync()/fdatasync() を呼び出す必要がない
- O_DSYNC フラグもある
  - fdatasync() と同様にデータのみ同期する
- O_RSYNC フラグもある
  - read 呼び出しが完了するまで戻らない

## O_DIRECT フラグ
- open 時に O_DIRECT フラグを指定すると、カーネルバッファを経由せずに直接ディスクにアクセスする
- 制約：
  - バッファはページ境界（通常4KB）にアラインメントされている必要
  - I/Oサイズもセクタサイズ（通常512バイト）の倍数
  - データベース等で使用（カーネルキャッシュを回避）

```bash
# ddコマンドでダイレクトI/O（iflag=direct）とバッファI/Oの比較
# 100MBのファイル作成
dd if=/dev/zero of=/tmp/testfile bs=1M count=100

# バッファI/O（通常）
time dd if=/tmp/testfile of=/dev/null bs=4096

# ダイレクトI/O
time dd if=/tmp/testfile of=/dev/null bs=4096 iflag=direct

# straceで違いを確認
strace -e open,read dd if=/tmp/testfile of=/dev/null bs=4096 count=10 2>&1 | grep -E "open|O_DIRECT"
strace -e open,read dd if=/tmp/testfile of=/dev/null bs=4096 count=10 iflag=direct 2>&1 | grep -E "open|O_DIRECT"
```

## close()
https://man7.org/linux/man-pages/man2/close.2.html
- fd を閉じる

## lseek()
https://man7.org/linux/man-pages/man2/lseek.2.html
- ファイルポジションを移動

## ポジション指定IO
https://man7.org/linux/man-pages/man2/pwrite.2.html

- pread()/pwrite() 関数を使用すると、ファイルポジションを変更せずに読み書きが可能

## truncate()/ftruncate()
https://man7.org/linux/man-pages/man2/truncate.2.html

## 多重IO
- 複数の fd に対して 同時にIOをしたい事がある
- この仕組みを自前で実装するのは大変
  - デッドロックの発生リスク
  - 単純なオーバーヘッド

### select()
https://man7.org/linux/man-pages/man2/select.2.html

- 複数のfdを監視し、I/O可能なfdを検出
- タイムアウト指定可能
- fd_set（ビットマップ）で管理：FD_SET, FD_CLR, FD_ISSET, FD_ZERO
- 制限：FD_SETSIZE（通常1024）まで

#### select()とシグナルのrace condition問題

**問題のシナリオ**
```c
while (!stop_flag) {     // 1. フラグチェック
    // ここでシグナルが来ると問題！
    select(...);         // 2. ブロック開始
}
```

フラグチェック後、select()呼び出し前にシグナルが来ると、
select()がタイムアウトするまでシグナルに反応できない。

**解決策：pselect()の使用**
```c
sigset_t origmask, sigmask;
sigemptyset(&sigmask);
sigaddset(&sigmask, SIGINT);
sigprocmask(SIG_BLOCK, &sigmask, &origmask);  // シグナルをブロック

while (!stop_flag) {
    // pselect()はアトミックにシグナルマスクを変更
    pselect(nfds, &readfds, NULL, NULL, &timeout, &origmask);
}
```

pselect()はシグナルマスクの変更とselect()をアトミックに実行するため、
race conditionを回避できる。

### poll()
https://man7.org/linux/man-pages/man2/poll.2.html

select()の改良版
- fdの数に制限なし（動的配列使用）
- より細かいイベント指定（POLLIN, POLLOUT, POLLERR等）
- タイムアウトをミリ秒単位で指定
- ppoll()でシグナル対応（pselect()と同様）

**1. selectの動作確認**
```bash
# ncで簡単なサーバーを作成し、straceで監視
nc -l 8080 &
NC_PID=$!

# 別ターミナルで
strace -p $NC_PID -e select,poll,read,write 2>&1

# 別ターミナルから接続
echo "Hello" | nc localhost 8080
```

**2. 複数fdの監視デモ**
```c
// select_demo.c
#include <sys/select.h>
#include <unistd.h>
#include <stdio.h>

int main() {
    fd_set readfds;
    struct timeval tv = {5, 0};  // 5秒タイムアウト

    FD_ZERO(&readfds);
    FD_SET(STDIN_FILENO, &readfds);  // 標準入力を監視

    printf("Waiting for input (5 sec timeout)...\n");
    int ret = select(STDIN_FILENO + 1, &readfds, NULL, NULL, &tv);

    if (ret > 0) printf("Input available!\n");
    else if (ret == 0) printf("Timeout!\n");
    else perror("select");

    return 0;
}
```

**カーネルソース参照**
- [select/poll実装](https://github.com/torvalds/linux/blob/master/fs/select.c)

## IO に関するカーネルの動作

### vfs

- 個別のファイルシステムを抽象化するための共通インターフェース
- 担当する処理：
  - ファイルシステムの共通処理
    - ディレクトリやファイルの管理
    - i-node 管理, パーミッション管理
    - https://github.com/torvalds/linux/blob/master/fs/read_write.c
  - 個別のファイルシステム固有処理の呼び出し
    - システムコールの個別fs対応
    - - https://github.com/torvalds/linux/tree/master/fs/ext4

- システムコール発行→割り込み発生→システムコールハンドラ→
- システムコール実行(read)→ パス名解決→対応するファイルシステムの read 呼び出し

### ページキャッシュ

- ディスクI/Oの高速化のためブロックデバイスの内容をメモリにキャッシュ
- キャッシュ管理の原則：
  - **時間的局所性**：最近使われたデータは再度使われる可能性が高い
  - **空間的局所性**：近くにあるデータも使われる可能性が高い
    - 先読み（readahead）：次のブロックを事前に読み込み（16-128KB動的調整）
    - 参考：[readaheadの実装](https://github.com/torvalds/linux/blob/master/mm/readahead.c)

- メモリ管理：
  - キャッシュは単調増加、メモリ不足時はLRUで解放
  - ページキャッシュ解放 vs スワッピングのトレードオフ
  - `/proc/sys/vm/swappiness`で調整（0-100、デフォルト60）

**1. キャッシュ状態の確認**
```bash
# 現在のメモリ状況
free -h
cat /proc/meminfo | grep -E "^(MemFree|Cached|Buffers)"

# 大きなファイルを読み込んでキャッシュに載せる
dd if=/dev/zero of=/tmp/bigfile bs=1M count=500
cat /tmp/bigfile > /dev/null

# キャッシュが増えたことを確認
free -h
```

**2. キャッシュの効果測定**
```bash
# 1回目の読み込み（ディスクから）
sync && echo 3 | sudo tee /proc/sys/vm/drop_caches
time cat /tmp/bigfile > /dev/null

# 2回目の読み込み（キャッシュから）
time cat /tmp/bigfile > /dev/null

# I/O統計を確認
iostat -x 1 5  # 別ターミナルで実行
```

**3. swappinessの確認と調整**
```bash
# 現在の設定確認
cat /proc/sys/vm/swappiness

# 一時的に変更（要root）
echo 10 | sudo tee /proc/sys/vm/swappiness
```

**カーネルソース参照**
- [ページキャッシュ実装](https://github.com/torvalds/linux/blob/master/mm/filemap.c)
- [readahead実装](https://github.com/torvalds/linux/blob/master/mm/readahead.c)
- [swappiness制御](https://github.com/torvalds/linux/blob/master/mm/vmscan.c)


### ページライトバック

- write()はユーザーバッファ→カーネルバッファへコピーして即座に返る
- カーネルバッファ→ディスクへの実際の書き込み = **ページライトバック**
- 書き込み待ちのページ = **dirtyページ**

#### ライトバックのタイミング
1. メモリ不足時
2. dirtyページのタイムアウト（デフォルト30秒）
3. sync/fsync呼び出し時

#### ライトバックの実装変遷
- **旧実装（bdflush）**：シングルスレッド、全バッファロックで性能問題
- **pdflush**：複数スレッド化、デバイス毎の並列処理
- **現在（writeback threads）**：カーネル2.6.32以降、per-bdi（デバイス毎）スレッド

参考：[buffer_head構造体](https://github.com/torvalds/linux/blob/master/include/linux/buffer_head.h)

**1. dirtyページの確認**
```bash
# 現在のdirtyページ量
cat /proc/meminfo | grep Dirty

# 大量のデータを書き込み（まだディスクには書かれていない）
dd if=/dev/zero of=/tmp/testwrite bs=1M count=100

# dirtyページが増加
cat /proc/meminfo | grep Dirty

# syncで強制的にディスクに書き込み
sync

# dirtyページが減少
cat /proc/meminfo | grep Dirty
```

**2. ライトバック設定の確認**
```bash
# dirtyページのしきい値（この量を超えるとライトバック開始）
cat /proc/sys/vm/dirty_background_ratio

# dirtyページの上限（これを超えるとプロセスがブロック）
cat /proc/sys/vm/dirty_ratio

# ライトバックのタイムアウト（センチ秒単位、デフォルト3000 = 30秒）
cat /proc/sys/vm/dirty_expire_centisecs

# ライトバックスレッドの起動間隔
cat /proc/sys/vm/dirty_writeback_centisecs
```

**3. writebackスレッドの観察**
```bash
# カーネルスレッドの確認
ps aux | grep -E "\[kworker.*writeback\]|\[flush\]"

# I/O統計でライトバック活動を確認
iostat -x 1
```

**カーネルソース参照**
- [writeback実装](https://github.com/torvalds/linux/blob/master/fs/fs-writeback.c)
- [backing-dev（per-bdiスレッド）](https://github.com/torvalds/linux/blob/master/mm/backing-dev.c)
